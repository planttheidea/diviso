import type { PartAction } from './actions.mjs';
import type { AnyStatefulPart, PartId } from './part.mjs';
import type { Dispatch, GetState, PartMap } from './store.mjs';
export type IsAny<T, True, False = never> = true | false extends (T extends never ? true : false) ? True : False;
export type IsEqual<Type = any> = (a: Type, b: Type) => boolean;
export type AnyFn<Args extends any[], Result> = (...a: Args) => Result;
export type FunctionalUpdate<State> = (prev: State) => State;
export type MaybePromise<Value> = Value | Promise<Value>;
export type NoInfer<T> = [T][T extends any ? 0 : never];
export type ResolvedValue<Value> = Value extends Promise<infer Result> ? ResolvedValue<Result> : Value;
export type Thunk<Result, State> = (dispatch: Dispatch, getState: GetState<State>) => Result;
export type Tuple<Type> = readonly [Type] | readonly Type[];
export type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void ? I : never;
export declare function createInternalActionType(type: string): string;
export declare function createProbeUnknownAction(): string;
export declare function getActionPartId(action: PartAction): PartId;
export declare function getActionPartIdDevTools(action: {
    action: PartAction;
}): PartId;
export declare function getConstructorName(value: any): string | null;
export declare function getId(): PartId;
export declare function getStatefulPartMap(parts: readonly AnyStatefulPart[]): PartMap;
export declare function identity<Value>(value: Value): Value;
export declare const isFallback: typeof Object.is;
export declare const is: (value1: any, value2: any) => boolean;
export declare function kindOf(value: any): string;
export declare function noop(): void;
export declare function toScreamingSnakeCase(string: string): string;
export declare function updateUniqueList(list: any[], item: any): void;
export declare function warn(message: string): void;
